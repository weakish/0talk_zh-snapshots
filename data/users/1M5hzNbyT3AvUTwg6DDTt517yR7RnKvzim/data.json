{
	"next_topic_id": 4,
	"topic": [
		{
			"topic_id": 1,
			"title": "成功注册了一个bit域名",
			"body": "昨天看到原来这个可以注册域名,就注册了一个.\nhttp://127.0.0.1:43110/cnmaple.bit/\n注册也是很简单的。\n[注册方法](http://127.0.0.1:43110/cnmaple.bit/?Post:5:bit%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C)",
			"added": 1475372226,
			"parent_topic_uri": "8_1NV87VmSkezRyz8NbFpdkYJsJUSfXx7LJa"
		},
		{
			"topic_id": 2,
			"title": "P2P 之Kademlia",
			"body": "Kademlia简述\nKademlia(简称Kad)属于一种典型的结构化P2P覆盖网络(Structured P2P Overlay Network)，以分布式的应用层全网方式来进行信息的存储和检索是其尝试解决的主要问题。在Kademlia网络中，所有信息均以的哈希表条目形式加 以存储，这些条目被分散地存储在各个节点上，从而以全网方式构成一张巨大的分布式哈希表。我们可以形象地把这张哈希大表看成是一本字典：只要知道了信息索 引的key，我们便可以通过Kademlia协议来查询其所对应的value信息，而不管这个value信息究竟是存储在哪一个节点之上。在eMule、 BitTorrent等P2P文件交换系统中，Kademlia主要充当了文件信息检索协议这一关键角色，但Kad网络的应用并不仅限于文件交换。下文的 描述将主要围绕eMule中Kad网络的设计与实现展开。\n\neMule的Kad网络中究竟存储了哪些信息?\n只要是能够表述成为字典条目形式的信息Kad网络均能存储，一个Kad网络能够同时存储多张分布式哈希表。以eMule为例，在任一时刻，其Kad网络均存储并维护着两张分布式哈希表，一张我们可以将其命名为关键词字典，而另一张则可以称之为文件索引字典。\na. 关键词字典：主要用于根据给出的关键词查询其所对应的文件名称及相关文件信息，其中key的值等于所给出的关键词字符串的 160比特SHA1散列，而其对应的value则为一个列表，在这个列表当中，给出了所有的文件名称当中拥有对应关键词的文件信息，这些信息我们可以简单 地用一个3元组条目表示：(文件名，文件长度，文件的SHA1校验值)，举个例子，假定存在着一个文件 “warcraft_frozen_throne.iso”，当我们分别以“warcraft”、“frozen”、“throne”这三个关键词来查询 Kad时，Kad将有可能分别返回三个不同的文件列表，这三个列表的共同之处则在于它们均包含着一个文件名为 “warcraft_frozen_throne.iso”的信息条目，通过该条目，我们可以获得对应iso文件的名称、长度及其160比特的SHA1校 验值。\nb. 文件索引字典：用于根据给出的文件信息来查询文件的拥有者(即该文件的下载服务提供者)，其中key的值等于所需下载文件的 SHA1校验值(这主要是因为，从统计学角度而言，160比特的SHA1文件校验值可以唯一地确定一份特定数据内容的文件)；而对应的value也是一个 列表，它给出了当前所有拥有该文件的节点的网络信息，其中的列表条目我们也可以用一个3元组表示：(拥有者IP，下载侦听端口，拥有者节点ID)，根据这 些信息，eMule便知道该到哪里去下载具备同一SHA1校验值的同一份文件了。\n\n利用Kad网络搜索并下载文件的基本流程是怎样的?\n基于我们对eMule的Kad网络中两本字典的理解，利用Kad网络搜索并下载某一特定文件的基本过程便很明白了，仍以 “warcraft_frozen_throne.iso”为例，首先我们可以通过warcraft、frozen、throne等任一关键词查询关键词 字典，得到该iso的SHA1校验值，然后再通过该校验值查询Kad文件索引字典，从而获得所有提供 “warcraft_frozen_throne.iso”下载的网络节点，继而以分段下载方式去这些节点下载整个iso文件。\n在上述过程中，Kad网络实际上所起的作用就相当于两本字典，但值得再次指出的是，Kad并不是以集中的索引服务器(如华语P2P源动力、 Razorback 2、DonkeyServer 等，骡友们应该很熟悉吧)方式来实现这两本字典的存储和搜索的，因为这两本字典的所有条目均分布式地存储在参与Kad网络的各节点中，相关文件信息、下载 位置信息的存储和交换均无需集中索引服务器的参与，这不仅提高了查询效率，而且还提高了整个P2P文件交换系统的可靠性，同时具备相当的反拒绝服务攻击能 力；更有意思的是，它能帮助我们有效地抵制FBI的追捕，因为俗话说得好：法不治众…看到这里，相信大家都能理解“分布式信息检索”所带来的好处了吧。但 是，这些条目究竟是怎样存储的呢?我们又该如何通过Kad网络来找到它们?不着急，慢慢来。\n\n什么叫做节点的ID和节点之间的距离?\nKad网络中的每一个节点均拥有一个专属ID，该ID的具体形式与SHA1散列值类似，为一个长达160bit的整数，它是由节点自己随机生成的， 两个节点拥有同一ID的可能性非常之小，因此可以认为这几乎是不可能的。在Kad网络中，两个节点之间距离并不是依靠物理距离、路由器跳数来衡量的，事实 上，Kad网络将任意两个节点之间的距离d定义为其二者ID值的逐比特二进制和数，即，假定两个节点的ID分别为a与b，则有：d=a XOR b。在Kad中，每一个节点都可以根据这一距离概念来判断其他节点距离自己的“远近”，当d值大时，节点间距离较远，而当d值小时，则两个节点相距很近。 这里的“远近”和“距离”都只是一种逻辑上的度量描述而已；在Kad中，距离这一度量是无方向性的，也就是说a到b的距离恒等于b到a的距离，因为a XOR b==b XOR a\n\n条目是如何存储在Kad网络中的?\n从上文中我们可以发现节点ID与条目中key值的相似性：无论是关键词字典的key，还是文件索引字典的key，都是160bit，而节点ID恰恰 也是160bit。这显然是有目的的。事实上，节点的ID值也就决定了哪些条目可以存储在该节点之中，因为我们完全可以把某一个条目简单地存放在节点ID 值恰好等于条目中key值的那个节点处，我们可以将满足(ID==key)这一条件的节点命名为目标节点N。这样的话，一个查找条目的问题便被简单地转化 成为了一个查找ID等于Key值的节点的问题。\n由于在实际的Kad网络当中，并不能保证在任一时刻目标节点N均一定存在或者在线，因此Kad网络规定：任一条目，依据其key的具体取值，该条目 将被复制并存放在节点ID距离key值最近(即当前距离目标节点N最近)的k个节点当中；之所以要将重复保存k份，这完全是考虑到整个Kad系统稳定性而 引入的冗余；这个k的取值也有讲究，它是一个带有启发性质的估计值，挑选其取值的准则为：“在当前规模的Kad网络中任意选择至少k个节点，令它们在任意 时刻同时不在线的几率几乎为0”；目前，k的典型取值为20，即，为保证在任何时刻我们均能找到至少一份某条目的拷贝，我们必须事先在Kad网络中将该条 目复制至少20份。\n由上述可知，对于某一条目，在Kad网络中ID越靠近key的节点区域，该条目保存的份数就越多，存储得也越集中；事实上，为了实现较短的查询响应 延迟，在条目查询的过程中，任一条目可被cache到任意节点之上；同时为了防止过度cache、保证信息足够新鲜，必须考虑条目在节点上存储的时效性： 越接近目标结点N，该条目保存的时间将越长，反之，其超时时间就越短；保存在目标节点之上的条目最多能够被保留24小时，如果在此期间该条目被其发布源重 新发布的话，其保存时间还可以进一步延长。\n\nKad网络节点需要维护哪些状态信息?\n在Kad网络中，每一个节点均维护了160个list，其中的每个list均被称之为一个k-桶(k-bucket)，如下图所示。在第i个 list中，记录了当前节点已知的与自身距离为2^i~2^(i+1)的一些其他对端节点的网络信息(Node ID，IP地址，UDP端口)，每一个list(k-桶)中最多存放k个对端节点信息，注意，此处的k与上文所提到的复制系数k含义是一致的；每一个 list中的对端节点信息均按访问时间排序，最早访问的在list头部，而最近新访问的则放在list的尾部。\n![kad bucket](http://127.0.0.1:43110/cnmaple.bit/img/r_k_bucket.png)\nk-桶中节点信息的更新基本遵循Least-recently Seen Eviction原则：当list容量未满(k-桶中节点个数未满k个)，且最新访问的对端节点信息不在当前list中时，其信息将直接添入list队 尾，如果其信息已经在当前list中，则其将被移动至队尾；在k-桶容量已满的情况下，添加新节点的情况有点特殊，它将首先检查最早访问的队首节点是否仍 有响应，如果有，则队首节点被移至队尾，新访问节点信息被抛弃，如果没有，这才抛弃队首节点，将最新访问的节点信息插入队尾。可以看出，尽可能重用已有节 点信息、并且按时间排序是k-桶节点更新方式的主要特点。从启发性的角度而言，这种方式具有一定的依据：在线时间长一点的节点更值得我们信任，因为它已经 在线了若干小时，因此，它在下一个小时以内保持在线的可能性将比我们最新访问的节点更大，或者更直观点，我这里再给出一个更加人性化的解释：MP3文件交 换本身是一种触犯版权法律的行为，某一个节点反正已经犯了若干个小时的法了，因此，它将比其他新加入的节点更不在乎再多犯一个小时的罪……-_-b\n由上可见，设计采用这种多k-bucket数据结构的初衷主要有二：a. 维护最近-最新见到的节点信息更新；b. 实现快速的节点信息筛选操作，也就是说，只要知道某个需要查找的特定目标节点N的ID，我们便可以从当前节点的k-buckets结构中迅速地查出距离N 最近的若干已知节点。\n\n在Kad网络中如何寻找某特定的节点?\n已知某节点ID，查找获得当前Kad网络中与之距离最短的k个节点所对应的网络信息(Node ID，IP地址，UDP端口)的过程，即为Kad网络中的一次节点查询过程(Node Lookup)。注意，Kad之所以没有把节点查询过程严格地定义成为仅仅只查询单个目标节点的过程，这主要是因为Kad网络并没有对节点的上线时间作出 任何前提假设，因此在多数情况下我们并不能肯定需要查找的目标节点一定在线或存在。\n整个节点查询过程非常直接，其方式类似于DNS的迭代查询：\na. 由查询发起者从自己的k-桶中筛选出若干距离目标ID最近的节点，并向这些节点同时发送异步查询请求；\nb .被查询节点收到请求之后，将从自己的k-桶中找出自己所知道的距离查询目标ID最近的若干个节点，并返回给发起者；\nc. 发起者在收到这些返回信息之后，再次从自己目前所有已知的距离目标较近的节点中挑选出若干没有请求过的，并重复步骤1；\nd. 上述步骤不断重复，直至无法获得比查询者当前已知的k个节点更接近目标的活动节点为止。\ne. 在查询过程中，没有及时响应的节点将立即被排除；查询者必须保证最终获得的k个最近节点都是活动的。\n简单总结一下上述过程，实际上它跟我们日常生活中去找某一个人打听某件事是非常相似的，比方说你是个Agent Smith，想找小李(key)问问他的手机号码(value)，但你事先并不认识他，你首先肯定会去找你所认识的和小李在同一个公司工作的人，比方说小 赵，然后小赵又会告诉你去找与和小李在同一部门的小刘，然后小刘又会进一步告诉你去找和小李在同一个项目组的小张，最后，你找到了小张，哟，正好小李出差 去了(节点下线了)，但小张恰好知道小李的号码，这样你总算找到了所需的信息。在节点查找的过程中，“节点距离的远近”实际上与上面例子中“人际关系的密 切程度”所代表的含义是一样的。\n最后说说上述查询过程的局限性：Kad网络并不适合应用于模糊搜索，如通配符支持、部分查找等场合，但对于文件共享场合来说，基于关键词的精确查找 功能已经基本足够了(值得注意的是，实际上我们只要对上述查找过程稍加改进，并可以令其支持基于关键词匹配的布尔条件查询，但仍不够优化)。这个问题反映 到eMule的应用层面来，它直接说明了文件共享时其命名的重要性所在，即，文件名中的关键词定义得越明显，则该文件越容易被找到，从而越有利于其在 P2P网络中的传播；而另一方面，在eMule中，每一个共享文件均可以拥有自己的相关注释，而Comment的重要性还没有被大家认识到：实际上，这个 文件注释中的关键词也可以直接被利用来替代文件名关键词，从而指导和方便用户搜索，尤其是当文件名本身并没有体现出关键词的时候。\n\n在Kad网络中如何存储和搜索某特定的条目?\n从本质上而言，存储、搜索某特定条目的问题实际上就是节点查找的问题。当需要在Kad网络中存储一个条目时，可以首先通过节点查找算法找到距离 key最近的k个节点，然后再通知它们保存条目即可。而搜索条目的过程则与节点查询过程也是基本类似，由搜索发起方以迭代方式不断查询距离key较近的节 点，一旦查询路径中的任一节点返回了所需查找的value，整个搜索的过程就结束。为提高效率，当搜索成功之后，发起方可以选择将搜索到的条目存储到查询 路径的多个节点中，作为方便后继查询的cache；条目cache的超时时间与节点-key之间的距离呈指数反比关系。\n\n一个新节点如何首次加入Kad网络?\n当一个新节点首次试图加入Kad网络时，它必须做三件事，其一，不管通过何种途径，获知一个已经加入Kad网络的节点信息(我们可以称之为节点 I)，并将其加入自己的k-buckets；其二，向该节点发起一次针对自己ID的节点查询请求，从而通过节点I获取一系列与自己距离邻近的其他节点的信 息；最后，刷新所有的k-bucket，保证自己所获得的节点信息全部都是新鲜的。\n[转自](http://127.0.0.1:43110/cnmaple.bit/?Post:9:Kademlia%E8%AF%A6%E8%A7%A3)",
			"added": 1475488291,
			"parent_topic_uri": "19_1NV87VmSkezRyz8NbFpdkYJsJUSfXx7LJa"
		},
		{
			"topic_id": 3,
			"title": "一种优化的 Kademlia 路由算法",
			"body": "1 引言\n随着网络的发展，尤其是大规模多媒体的开发\n和应用，在传统的 C/S、B/S 的结构中带宽和服务器\n的处理能力成为了瓶颈。相比之下，P2P 网络具有较\n高的自主性、可伸缩性、可靠性和对称性。尤其是\n可伸缩性在 P2P 网络中变成了研究热点。怎样高速\n和有效的查询资源节点是一个非常重要的问题。P2P\n路由算法根据网络的组织结构、数据的分布和路由、\n定位方式主要分为两类：结构化的 P2P 和非结构化\n的 P2P。\n结构化的哈希表（DHT）主要被用在结构化的 P2P\n网络中。它是由在广域空间内分部的纵多分散的节点\n组成的一个大的哈希表。这个哈希表被分成众多不连\n续的部分。每个节点通过加密的哈希函数和统一的域\n名空间管理各自的区域。同时结构化的哈希表（DHT）\n还具有可伸缩性、可靠性、鲁棒性和自组织的特点。\n同时每个节点可以动态的加入和退出网络。目前，典\n型的结构化的 P2P 路由算法包括 CAN，Chord，Pastry\n等等。\nKademlia 是一种基于 DHT 的路由算法。和前边\n提到的其它的路由算法相比，Kademlia 是一种新型的\nDHT 覆盖拓扑结构，并且在查询速度上有明显的几个\n优点。它的特别之处在于利用 XOR metric 测量两个节\n点之间的距离，然而在查询效率和缓存策略上存在着\n不足。针对这种情况，本文引用了一种新的策略，该\n策略采用了快表技术和加权设置策略。这样就避免了\n在高的刷新频率下缓存查询效率低的问题，为更高的\n查询命中率提供了更集中的热点资源。\n文章的组织如下：第二部分介绍了原始的\nKademlia 算法和它的数据结构；第三部分是改进的\nKademlia 路由算法；第四部分通过实验来证明该算法\n的有效性；最后一部分为结论。\n\n2 Kademlia 算法描述\nKademlia 协议最早出现在 2002，美国的 PetarP.\nMaymounkov and David Mazieres 发表了“Kademlia:\n基于 XOR metric 的点对点的信息系统”的文章引起了\n人们的重视。随后 2005 年，基于 DHT 的 Kademlia\n路由算法首次运用在 BiTtorrent 中。之后，该算法在\n很多 P2P 的网络中得到运用，如 BitComet，BitSpirit\n和 eMule，它们所采用的获取值、节点和关键字的算\n法不同。\n在 Kademlia 算法中，每个节点都有一个长度为\n160 位的字符串作为唯一标识，这 160 个字符是通过\n随机函数选取自由组合而成的。同时，每个节点都有\n一个<关键字，值>的一个值对（但并不是必须的），\n值存储在最近的节点上。为了使这些值处于活跃状态，\n需要周期性的发布。\nKademlia 哈希表的组织形式为一个二叉树，叶子\n为 Kademlia 节点。根据节点 ID 的最短的唯一前缀给\n每个节点赋值，每个节点根据其 ID 插入树中的某一\n位置。从树根开始，每一位代表一个二叉树的分支。\n每个节点都拥有整个二叉树的一部分空间，除了自身\n之外，其余部分又被划分成一系列连续的子树。最高\n子树是除了根节点之外的整个二叉树的一半，下一个\n子树是剩下部分的一半，等等，以此类推。节点 0010\n如图 1 所示。\nNode subtree\nFigure 1. Node subtree\n图 1. 节点子树\n根据子树的结构，XOR 度量被用于计算两个节\n点之间的距离。举例，节点 x 和 y 之间的距离用表达\n式 d(x，y) = x⊕y 表示，从该表达式中我们可以看出，\n高的数字比低的数字有更多的影响。正如我们所知道\n的：XOR 度量是单向的，每个 x 都有唯一的 y 和唯一\n的 d(x，y)和其相对应，搜索相同关键字会沿着同样的\n路径进行，该路径独立于起点。如果我们在该路径上\n只存储<关键字，值>对的话，这种方法能减轻热点区\n的压力，提高查询效率。\n在 Kademlia 中，任何节点和它周围的节点都保\n持 logN（N 为节点数，logN 默认值为 160）个连接。\n此外，每个节点都有一个特殊的路由表，被称为\nk-bucket 表，该表和其它节点的三元组（IP 地址，UDP\n端口，节点 ID）至多包含 K 个入口。同时，在覆盖的\n节点中，为了使路由更加牢靠，通过跨越几个不相连\n的路径，参数 K 是一个冗余因子。例如 k-bucket[i]，\n节点之间的信息被存储，节点之间的距离在 2i 和 2i+1\n之间。图 2 显示了 K=20 时，k-bucket 表的情况。\nk-bucket table\nFigure 2. k-bucket table\n图 2. k-bucket 表\n总之，在 Kademlia 算法优点如下：节点 ID 之间\n的关系，在 k-bucket 中节点和节点位置之间的距离都\n被定义。\n然而，高速缓存策略有一些缺点。首先，要成功\n查询<关键字，值>时，没有必要去存储这个值。第二，\n产生和搜索资源降低了效率，尤其是热点节点。如果\n资源是无效了，关于它的信息在每一个相关的节点上\n将会被清除，因此，热点节点的资源要在缓冲中重新\n建立。\n\n3 改进的 Kademlia 路由算法\n为了改进以上存在的问题，本文提出了一种改进\n的 Kademlia 算法，该算法主要通过使用快表和加权设\n置来提高热点区查询的效率。\n3.1 高速缓存策略\n由于最初的 Kademlia 算法不能区分热点节点和\n普通节点，新的缓存策略提出，在每个节点中除了现\n存的 k-bucket 外，在空间允许的基础上，要增加一个\n新表用于存储存在高访问率的节点信息。在本文中，\n该表被称为快查询表或快表，快表的每个记录包括资\n源和供应者即<关键字，值>对。每个节点的查询时间\n也被记录在表中，因此热区的存储能力和缓冲能力都\n被提高了。\n热区由 counter 的值来定义，例如，我们定义\ncounter>3 的资源为热区，因此，检查每个节点的\ncounter，如果大于 3，则将该节点存储到邻居节点或\n者有最靠近 key 值的节点。注意，热区对于邻居节点\n312 2010 National Conference of Higher Vocational and Technical Education on Computer Information 978-1-935068-31-0 © 2010 SciRes.\n来说意味着要把热区资源存储在表中。拥有最靠近的\nkey 的节点的存储操作的含义是发表该 key 的信息。\n3.2 更新快表\n更新快表就犹如在 Kedemlia 路由模型中更新\nk-bucket，当一个新的记录被加入到快表中，步骤如下:\n（1）如果该资源已经在快表中存在，counter+ =\n1，然后把指针移向尾部\n（2）如果资源不存在，并且记录的数目少于 k，\n把资源添加到快表的尾部\n（3）如果表是空表，则删除表顶部的记录，然后\n在表的尾部增加一个新记录。\n\n4 仿真实验\n本文中，运用 PlanetSim 来运行和评估 Kademlia\n路由算法。PlanetSim 是一个网络模拟器，用于大规模\noverlay 服务的实验框架。它提供了一个统一的方法来\n模拟，并且可以清晰的区分算法的设计以及基于之上\n的应用和服务。因为节点是随意的插入 PlanetSim 平\n台上，算法的有效性可以保证。PlanetSim 提供了一系\n列的评估指标，如路由步长、查询时间延迟、查询成\n功次数和失败次数等等。\n在本文中，该模拟实验主要通过评估路由步长、\n查询时间延迟等指标来比较新旧算法关于热区查询的\n问题。查询数增加，参数不变。\n首先考虑平均路由步长，单位是一个跳变。图 3\n显示了平均路由步长和查询数量的关系。“Orgn Kad”\n表示原始的 Kademlia 协议，而“New Kad”表示改进的\n算法。结果证明，改进的算法没有显著增加系统的负\n担，但可以通过增加一个合适快表的方法来改善热区\n搜索。\nAverage routing steps\nFigure 3. Average routing steps\n图 3. 平均路由步长\n同样的环境下，查询时间延时也被检测。查询时\n间延时被定义为平均时间延时，单位是毫秒。图 4 表\n明，y 值的变化依赖于 x 轴的值，通过 y 轴可以看出，\n随着查询数目的增加，查询时间延时会减少。统计学\n数据证明，改进的 Kademlia 算法在减少查询时间延时\n方面具有显著性。\nQuery time delay\nFigure 4. Query time delay\n图 4. 查询时间延时\n\n5 结束语\n本文重点关注的问题是 P2P 网络中的如何高效的\n发现节点和检索资源的问题。重点分析了 Kademlia\n算法和改进的 Kademlia 路由算法。在真正的 P2P 网络\n中，利用快表查询和加权设置方法可以加快热区的查\n询速度。实验结果证明，改进的算法具有较低的路由\n步长和查询时间延时，同时可靠性也得到了提高。\n\n[转自Maple's Blog](http://127.0.0.1:43110/cnmaple.bit/?Post:10:%E4%B8%80%E7%A7%8D%E4%BC%98%E5%8C%96%E7%9A%84+Kademlia+%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95)",
			"added": 1475550947,
			"parent_topic_uri": "19_1NV87VmSkezRyz8NbFpdkYJsJUSfXx7LJa"
		}
	],
	"topic_vote": {
		"12_1NV87VmSkezRyz8NbFpdkYJsJUSfXx7LJa": 1
	},
	"next_comment_id": 7,
	"comment": {
		"6_1Q7UWk3im88kJkzmhzfD5q44rQDXLatxYq": [
			{
				"comment_id": 1,
				"body": "http://127.0.0.1:43110/1Xu7L66gqq5dc7LEiHPgo9n54F9xq7uym/   这个是我才建立的。感觉还不错",
				"added": 1475371259
			}
		],
		"1_1M5hzNbyT3AvUTwg6DDTt517yR7RnKvzim": [
			{
				"comment_id": 2,
				"body": "> [ysc3839](#comment_26_13RFJdsXQGN5cfMK8GctB6nQZ5xwLmjcfB): 你的网站打不开……NO PEERS FOUND\n\n不是吧~~我看到已经有几个了。。你现在在刷下呢？？？",
				"added": 1475392774
			},
			{
				"comment_id": 4,
				"body": "> [mba](#comment_14_15Z67QmyH6MTfk3pDfBR635kVie5DaokHd): Registering a .bit domain costs only around 0.02 namecoin ($0.008)。看到这个就已经完全不像注册了。\n\n不要钱的啊",
				"added": 1475414375
			}
		],
		"1_1DhW5omP4x5oVKtvw9sjW6MLd48qSZKZ3L": [
			{
				"comment_id": 3,
				"body": "合适的宣传与价值的体现",
				"added": 1475405380
			}
		],
		"13_1NwWoM1qGUV9gjLG7QGyhqsRxKKga2rhtf": [
			{
				"comment_id": 5,
				"body": "感觉好屌～",
				"added": 1475498270
			}
		],
		"1_18SfHvAVWv7TpzrNaatMMx4PHZ9YJwfSbD": [
			{
				"comment_id": 6,
				"body": "加入手机估计就完美了",
				"added": 1475979141
			}
		]
	},
	"comment_vote": {}
}